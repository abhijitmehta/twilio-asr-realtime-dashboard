"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("./logger");
const entity_1 = require("./entity");
const rfc6902_1 = require("rfc6902");
const retryingqueue_1 = require("./retryingqueue");
const utils_1 = require("./utils");
/**
 * @class
 * @alias Document
 * @classdesc Represents a Sync Document, the contents of which is a single JSON object.
 * @property {String} sid The immutable identifier of this document, assigned by the system.
 * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer
 * to this document during creation. Globally unique among other Documents.
 * @property {Object} value The contents of this document.
 *
 * @fires Document#removed
 * @fires Document#removedRemotely
 * @fires Document#updated
 * @fires Document#updatedRemotely
 */
class SyncDocument extends entity_1.SyncEntity {
    /**
     * @private
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        this.actionQueue = new retryingqueue_1.RetryingQueue();
        this.descriptor = descriptor;
        this.descriptor.data = this.descriptor.data || {};
    }
    // private props
    get uri() { return this.descriptor.url; }
    get revision() { return this.descriptor.revision; }
    get lastEventId() { return this.descriptor.last_event_id; }
    static get type() { return 'document'; }
    get type() { return 'document'; }
    // public props, documented along with class description
    get sid() { return this.descriptor.sid; }
    get value() { return this.descriptor.data; }
    get uniqueName() { return this.descriptor.unique_name || null; }
    /**
     * Update data entity with new data
     * @private
     */
    _update(update) {
        switch (update.type) {
            case 'document_updated':
                if (update.id > this.lastEventId) {
                    let originalData = this.descriptor.data;
                    this.descriptor.last_event_id = update.id;
                    this.descriptor.revision = update.document_revision;
                    this.descriptor.data = update.document_data;
                    this.traverse(originalData, update.document_data, false);
                    this.emit('updated', update.document_data, false);
                    this.emit('updatedRemotely', update.document_data);
                    this.services.storage.update(this.type, this.sid, this.uniqueName, { last_event_id: update.id, revision: update.document_revision, data: update.document_data });
                }
                break;
            case 'document_removed':
                this.onRemoved(false);
                break;
        }
    }
    /**
     * Calculate diff between old and new data
     * @private
     */
    traverse(originalData, updatedData, isLocalEvent) {
        let diff = rfc6902_1.createPatch(originalData, updatedData);
        diff.forEach((row) => {
            if (row.op === 'add') {
                this.emit('keyAdded', row.path, row.value, isLocalEvent);
                if (!isLocalEvent) {
                    this.emit('keyAddedRemotely', row.path, row.value);
                }
            }
            else if (row.op === 'replace') {
                this.emit('keyUpdated', row.path, row.value, isLocalEvent);
                if (!isLocalEvent) {
                    this.emit('keyUpdatedRemotely', row.path, row.value);
                }
            }
            else if (row.op === 'remove') {
                this.emit('keyRemoved', row.path, isLocalEvent);
                if (!isLocalEvent) {
                    this.emit('keyRemovedRemotely', row.path);
                }
            }
        });
    }
    /**
     * @returns {Object} Internal data of entity
     * For now use a 'value' property instead
     * @private
     */
    get(path) {
        // return !path ? this.value : this.value(path);
        return this.value;
    }
    /**
     * Assign new contents to this document.
     * @param {Object} value The new contents to assign.
     * @param {Boolean} [conditional=false] Determines whether to detect remote modifications that would race
     * with this new value.
     * @returns {Promise<Object>} A promise describing the outcome of the set.
     * Among common network failures and incorrect permissions, this promise will be rejected if value was
     * remotely modified and the `conditional` flag was set.
     * @public
     */
    set(value, conditional) {
        return this._actualSet(value, conditional ? () => { throw new Error('Revision mismatch'); }
            : null);
    }
    /**
     * @private
     */
    _actualSet(data, conflictResolver) {
        let resolver;
        let arg = { data,
            revision: (conflictResolver ? this.revision : undefined) };
        if (conflictResolver) {
            resolver = (err) => __awaiter(this, void 0, void 0, function* () {
                if (err.status === 412) {
                    yield this.softSync();
                    return { revision: this.revision,
                        data: conflictResolver(utils_1.deepClone(this.value)) };
                }
                throw err;
            });
        }
        return this.actionQueue
            .add(this._set.bind(this), this.uri, arg, resolver)
            .then(result => {
            if (result.last_event_id > this.descriptor.last_event_id) {
                // Ignore returned value if we already got a newer one
                this.descriptor.revision = result.revision;
                this.descriptor.data = result.data;
                this.descriptor.last_event_id = result.last_event_id;
                this.services.storage.update(this.type, this.sid, this.uniqueName, { last_event_id: result.last_event_id, revision: result.revision, data: result.data });
            }
            this.emit('updated', this.value, true);
            return this.value;
        });
    }
    /**
     * Schedules a modification to this document that will apply a mutation function.
     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.
     * May be called multiple times, particularly if this Document is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the Document will have made the particular transition described
     * by this function.
     * @return {Promise<Object>}
     * @public
     */
    mutate(mutator) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._actualSet(mutator(utils_1.deepClone(this.value)), mutator);
        });
    }
    /**
     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.
     * @return {Promise<Object>} A promise resolving to the modified item in its new state.
     * @public
     */
    update(obj) {
        return this.mutate(remote => Object.assign(remote, obj));
    }
    _set(context, param) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.services.network.post(this.uri, { data: param.data }, param.revision);
            return { revision: response.body.revision, data: param.data, last_event_id: response.body.last_event_id };
        });
    }
    /**
     * Get new data from server
     * @private
     */
    softSync() {
        return this.services.network.get(this.uri)
            .then(response => {
            this._update({ type: 'document_updated',
                id: response.body.last_event_id,
                document_revision: response.body.revision,
                document_data: response.body.data }); // eslint-disable-line camelcase
            return this;
        })
            .catch(err => {
            if (err.status === 404) {
                this.onRemoved(false);
            }
            else {
                logger_1.default.error(`Can't get updates for ${this.sid}:`, err);
            }
        });
    }
    /**
     * Get value by given path
     * @param {string} path JSON path
     * @private
     */
    /*
    _value(path) {
      let result;
      try {
        let pathArr = path.replace(/^\/|\/$/gm, '').split('/');
        let obj = this.data;
        pathArr.forEach((el) => { obj = obj[el]; });
        result = obj;
      } catch (e) {
        log.warn('Failed to get value:', e);
      }
      return result;
    }
    */
    onRemoved(locally) {
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        // Should also do some cleanup here
        this.emit('removed', locally);
        if (!locally) {
            this.emit('removedRemotely');
        }
    }
    /**
     * Delete a document
     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.
     * @public
     */
    removeDocument() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.network.delete(this.uri);
            this.onRemoved(true);
        });
    }
}
exports.SyncDocument = SyncDocument;
exports.default = SyncDocument;
/**
 * Applies a transformation to the document value.
 * @callback Document~Mutator
 * @param {Object} data The current value of the item in the cloud.
 * @return {Object} The desired new value for the item.
 */
/**
 * Fired when the document is removed, whether the remover was local or remote.
 * @event Document#removed
 * @param {Boolean} - 'true' if the item was removed by local code, 'false' otherwise
 */
/**
 * Fired when the document is removed by remote code.
 * @event Document#removedRemotely
 */
/**
 * Fired when the document's contents have changed, whether the updater was local or remote.
 * @event Document#updated
 * @param {Object} - A snapshot of the document's new contents.
 * @param {Boolean} - Equals 'true' if item was removed by local actor, 'false' otherwise
 */
/**
 * Fired when a document's contents were changed by remote code.
 * @event Document#updatedRemotely
 * @param {Object} - A snapshot of the document's new contents.
 */
