"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const xxhashjs_1 = require("xxhashjs");
const Twilsock = require("twilsock");
const twilio_transport_1 = require("twilio-transport");
const twilio_ems_client_1 = require("twilio-ems-client");
const Notifications = require("twilio-notifications");
const utils_1 = require("./utils");
const logger_1 = require("./logger");
const configuration_1 = require("./configuration");
const subscriptions_1 = require("./subscriptions");
const router_1 = require("./router");
const network_1 = require("./network");
const syncdocument_1 = require("./syncdocument");
const synclist_1 = require("./synclist");
const syncmap_1 = require("./syncmap");
const clientInfo_1 = require("./clientInfo");
const entitiesCache_1 = require("./entitiesCache");
const storage_1 = require("./services/storage");
const utils_2 = require("./utils");
// TODO: Pick some small library and use it instead
const deferred_1 = require("./utils/deferred");
const syncerror_1 = require("./syncerror");
const syncstream_1 = require("./streams/syncstream");
const SYNC_PRODUCT_ID = 'data_sync';
const SDK_VERSION = require('../package.json').version;
function subscribe(subscribable) {
    subscribable._subscribe();
    return subscribable;
}
function createPayload(name, purpose, context, data) {
    return { unique_name: name,
        purpose: purpose,
        context: context,
        data: data };
}
function decompose(arg) {
    if (!arg) {
        return { id: null, purpose: null, data: null, context: null, mode: null, optimistic: false };
    }
    if (typeof arg === 'string') {
        return { id: arg, purpose: null, data: null, context: null, mode: null, optimistic: false };
    }
    return { id: arg.uniqueName || arg.sid || arg.id,
        purpose: arg.purpose,
        data: arg.data,
        context: arg.context,
        mode: arg.mode,
        optimistic: !!arg.optimistic };
}
/**
 * @class Client
 * @classdesc
 * Client for the Twilio Sync service
 *
 * @property {Client#ConnectionState} connectionState - Contains current service connection state.
 * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].
 */
class Client extends events_1.EventEmitter {
    /*
     * @constructor
     * @param {string} Token Twilio access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     */
    constructor(fpaToken, options = {}) {
        super();
        if (!fpaToken) {
            throw new Error('Sync library needs a valid Twilio token to be passed');
        }
        if (options.hasOwnProperty('logLevel')) {
            logger_1.default.setLevel(options.logLevel);
        }
        this.productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        let twilsock = options.twilsockClient = options.twilsockClient || new Twilsock(fpaToken, options);
        let transport = options.transport = options.transport || new twilio_transport_1.Transport(options.twilsockClient, { concurrentHttpRequestLimit: 20 });
        let emsClient = options.emsClient = options.emsClient || new twilio_ems_client_1.EmsClient(options);
        let notifications = options.notificationsClient = options.notificationsClient || new Notifications(fpaToken, options);
        let config = new configuration_1.Configuration(null, options);
        let network = new network_1.Network(this.productId, new clientInfo_1.ClientInfo(SDK_VERSION), config, transport);
        let storage = new storage_1.SessionStorage(config);
        this.localStorageId = null;
        this.fpaToken = fpaToken;
        this.authData = new deferred_1.Deferred();
        this.authData.promise.then(response => this.handleEmsResponse(response));
        emsClient.once('response', response => this.authData.update(response));
        emsClient.setToken(fpaToken).catch(e => { logger_1.default.warn('Failed to set token', e); });
        twilsock.connect();
        this.services = {
            config,
            twilsock,
            notifications,
            network,
            emsClient,
            storage,
            router: null,
            subscriptions: null
        };
        let subscriptions = new subscriptions_1.Subscriptions(this.services);
        let router = new router_1.Router({ config, subscriptions, notifications });
        this.services.router = router;
        this.services.subscriptions = subscriptions;
        this.entities = new entitiesCache_1.EntitiesCache();
        notifications.on('connectionStateChanged', () => {
            this.emit('connectionStateChanged', this.services.notifications.connectionState);
        });
    }
    /**
     * Current version of Sync client.
     * @name Client#version
     * @type String
     * @readonly
     */
    static get version() { return SDK_VERSION; }
    get connectionState() { return this.services.notifications.connectionState; }
    handleEmsResponse(response) {
        this.services.config.updateToken(response.token);
        try {
            let identity = response.identity;
            let serviceSid = response.serviceSids[this.productId];
            let storageId = xxhashjs_1.h64().update(`TW::${identity}::${serviceSid}`).digest().toString(16);
            this.services.storage.updateStorageId(storageId);
        }
        catch (e) {
            logger_1.default.error('Failed to initialize persistent storage', e);
        }
    }
    /**
     * Returns promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     * @private
     */
    ensureReady() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.authData.promise;
        });
    }
    storeRootInSessionCache(type, id, value) {
        // can't store without id
        if (!this.services.config.sessionStorageEnabled || !id) {
            return;
        }
        let valueToStore = utils_2.deepClone(value);
        if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {
            valueToStore['last_event_id'] = null;
            delete valueToStore['items'];
        }
        this.services.storage.store(type, id, valueToStore);
    }
    readRootFromSessionCache(type, id) {
        if (!this.services.config.sessionStorageEnabled || !id) {
            return null;
        }
        return this.services.storage.read(type, id);
    }
    _get(baseUri, id, optimistic = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!id) {
                return null;
            }
            const uri = new utils_1.UriBuilder(baseUri).pathSegment(id)
                .queryParam('Include', optimistic ? 'items' : undefined).build();
            try {
                let response = yield this.services.network.get(uri);
                return response.body;
            }
            catch (err) {
                if (err.status === 404) {
                    return null;
                }
                throw err;
            }
        });
    }
    _createDocument(id, data) {
        let requestBody = {
            unique_name: id,
            data: data
        };
        return this.services.network.post(this.services.config.documentsUri, requestBody).then(response => response.body);
    }
    _getDocument(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));
        });
    }
    _createList(id, purpose, context) {
        let payload = createPayload(id, purpose, context);
        return this.services.network.post(this.services.config.listsUri, payload).then(response => response.body);
    }
    _getList(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));
        });
    }
    _createMap(id) {
        let requestBody = {
            unique_name: id,
        };
        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);
    }
    _getMap(id, optimistic = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));
        });
    }
    _getStream(id, optimistic = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.readRootFromSessionCache(syncstream_1.SyncStream.type, id)
                || this._get(this.services.config.streamsUri, id, optimistic));
        });
    }
    _createStream(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestBody = {
                unique_name: id,
            };
            const response = yield this.services.network.post(this.services.config.streamsUri, requestBody);
            const streamDescriptor = response.body;
            return streamDescriptor;
        });
    }
    getCached(id, type) {
        if (id) {
            return this.entities.get(id, type) || null;
        }
        return null;
    }
    removeFromCacheAndSession(type, sid, uniqueName) {
        this.entities.remove(sid);
        if (this.services.config.sessionStorageEnabled) {
            this.services.storage.remove(type, sid, uniqueName);
        }
    }
    /**
     * Open a Sync Document by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Document.
     * @return {Promise<List>} a promise which resolves after the document is successfully read (or created).
     * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    document(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureReady();
            let { id, data, mode } = decompose(arg);
            let docFromInMemoryCache = this.getCached(id, 'document');
            if (docFromInMemoryCache) {
                return docFromInMemoryCache;
            }
            else {
                let docDescriptor = yield this._getDocument(id);
                if (!docDescriptor) {
                    if (mode === 'open') {
                        throw new syncerror_1.default('Not found', 404);
                    }
                    else {
                        try {
                            docDescriptor = yield this._createDocument(id, data);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.document(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
                this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, id, docDescriptor);
                let syncDocument = new syncdocument_1.SyncDocument(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
                syncDocument = this.entities.store(syncDocument);
                return subscribe(syncDocument);
            }
        });
    }
    /**
     * Open a Sync Map by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Map.
     * @return {Promise<Map>} a promise which resolves after the map is successfully read (or created).
     * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    map(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureReady();
            let { id, mode, optimistic } = decompose(arg);
            let mapFromInMemoryCache = this.getCached(id, 'map');
            if (mapFromInMemoryCache) {
                return mapFromInMemoryCache;
            }
            else {
                let mapDescriptor = yield this._getMap(id, optimistic);
                if (!mapDescriptor) {
                    if (mode === 'open') {
                        throw new syncerror_1.default('Not found', 404);
                    }
                    else {
                        try {
                            mapDescriptor = yield this._createMap(id);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.map(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
                this.storeRootInSessionCache(syncmap_1.SyncMap.type, id, mapDescriptor);
                let syncMap = new syncmap_1.SyncMap(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
                syncMap = this.entities.store(syncMap);
                return subscribe(syncMap);
            }
        });
    }
    /**
     * Open a Sync List by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync List.
     * @return {Promise<List>} a promise which resolves after the list is successfully read (or created).
     * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    list(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureReady();
            let { id, purpose, context, mode } = decompose(arg);
            let listFromInMemoryCache = this.getCached(id, 'list');
            if (listFromInMemoryCache) {
                return listFromInMemoryCache;
            }
            else {
                let listDescriptor = yield this._getList(id);
                if (!listDescriptor) {
                    if (mode === 'open') {
                        throw new syncerror_1.default('Not found', 404);
                    }
                    else {
                        try {
                            listDescriptor = yield this._createList(id, purpose, context);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.list(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
                this.storeRootInSessionCache(synclist_1.SyncList.type, id, listDescriptor);
                let syncList = new synclist_1.SyncList(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
                syncList = this.entities.store(syncList);
                return subscribe(syncList);
            }
        });
    }
    /**
     * Open a Sync Message Stream (SyncStream) by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Message Stream.
     * @return {Promise<Stream>} a promise which resolves after the stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     */
    stream(arg) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureReady();
            let { id, mode, optimistic } = decompose(arg);
            let streamFromInMemoryCache = this.getCached(id, syncstream_1.SyncStream.type);
            if (streamFromInMemoryCache) {
                return streamFromInMemoryCache;
            }
            else {
                let streamDescriptor = yield this._getStream(id, optimistic);
                if (!streamDescriptor) {
                    if (mode === 'open') {
                        throw new syncerror_1.default('Not found', 404);
                    }
                    else {
                        try {
                            streamDescriptor = yield this._createStream(id);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.stream(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
                this.storeRootInSessionCache(syncstream_1.SyncStream.type, id, streamDescriptor);
                const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);
                let syncStream = new syncstream_1.SyncStream(this.services, streamDescriptor, streamRemovalHandler);
                syncStream = this.entities.store(syncStream);
                return subscribe(syncStream);
            }
        });
    }
    /**
     * Gracefully shutdown the libray
     * Currently it is not properly implemented and being used only in tests
     * But should be made a part of public API
     * @private
     */
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.subscriptions.shutdown();
            yield this.services.twilsock.disconnect();
        });
    }
    /**
     * Set new auth token
     * @param {string} token New token to set
     * @return {Promise}
     * @public
     */
    updateToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.services.emsClient.setToken(token);
            this.services.config.updateToken(response.token);
            yield Promise.all([
                this.services.notifications.updateToken(token),
                this.services.twilsock.updateToken(token)
            ]);
            this.fpaToken = token;
        });
    }
}
exports.Client = Client;
exports.SyncClient = Client;
exports.default = Client;
/**
 * Indicates current state of connection between the client and Sync service.
 * <p>Valid options are as follows:
 * <li>'connecting' - client is offline and connection attempt is in process.
 * <li>'connected' - client is online and ready.
 * <li>'disconnecting' - client is going offline as disconnection is in process.
 * <li>'disconnected' - client is offline and no connection attempt is in process.
 * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.
 * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.
 * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState
 */
/**
 * These options can be passed to Client constructor
 * @typedef {Object} Client#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
 */
/**
 * Fired when connection state has been changed.
 * @param {Client#ConnectionState} connectionState Contains current service connection state.
 * @event Client#connectionStateChanged
 */
