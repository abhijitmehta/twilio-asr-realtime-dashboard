import { SyncEntity, EntityServices, RemovalHandler } from './entity';
import { ListItem as Item } from './listitem';
import { Paginator } from './paginator';
import { Mutator } from './interfaces/mutator';
interface ListServices extends EntityServices {
}
interface ListDescriptor {
    sid: string;
    url: string;
    revision: string;
    last_event_id: number;
    links: any;
    unique_name: string;
}
/**
 * @class
 * @alias List
 * @classdesc Represents a Sync List, which stores an ordered list of values.
 * @property {String} sid - List unique id, immutable identifier assigned by the system
 * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation
 *
 * @fires List#collectionRemoved
 * @fires List#collectionRemovedRemotely
 * @fires List#itemAdded
 * @fires List#itemAddedRemotely
 * @fires List#itemRemoved
 * @fires List#itemRemovedRemotely
 * @fires List#itemUpdated
 * @fires List#itemUpdatedRemotely
 */
declare class SyncList extends SyncEntity {
    private descriptor;
    private actionQueue;
    private cache;
    private context;
    /**
     * @private
     */
    constructor(services: ListServices, descriptor: ListDescriptor, removalHandler: RemovalHandler);
    readonly uri: string;
    readonly revision: string;
    readonly lastEventId: number;
    readonly links: any;
    static readonly type: string;
    readonly type: string;
    readonly sid: string;
    readonly uniqueName: string;
    private __set(location, param);
    /**
     * Add a new item to the list.
     * @param {Object} value Value to be added
     * @returns {Promise<ListItem>} A newly added item.
     * @public
     */
    push(value: any): Promise<Item>;
    /**
     * Assign new value to an existing item, given its index.
     * @param {Number} index Index of an item to be updated
     * @param {Object} value New value to be assigned to an item
     * @returns {Promise<ListItem>} A promise with updated item containing latest known value.
     * A promise will be rejected if value was remotely modified.
     * @public
     */
    set(index: number, value: Object): Promise<Item>;
    /**
     * @private
     */
    _actualSet(index: number, value: Object, resolver?: Mutator): Promise<Item>;
    /**
     * Modify an existing item by applying a mutation function to it.
     * @param {Number} index Index of an item to be changed
     * @param {List~Mutator} mutator A function that outputs a new value based on the existing value
     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.
     * A promise will be rejected if an item was not found.
     * @public
     */
    mutate(index: number, mutator: Mutator): Promise<Item>;
    /**
     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.
     * @param {Number} index Index of an item to be changed
     * @param {Object} obj Set of fields to update
     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.
     * A promise will be rejected if an item was not found.
     * @public
     */
    update(index: number, obj: Object): Promise<Item>;
    /**
     * Delete an item, given its key.
     * @param {number} index Index of an item to be removed
     * @returns {Promise<void>} A promise to remove an item.
     * A promise will be rejected if an item was not found.
     * @public
     */
    remove(index: number): Promise<void>;
    /**
     * Retrieve an item by List key.
     * @param {Number} index Item index in a List
     * @returns {Promise<ListItem>} A promise with an item containing latest known value.
     * A promise will be rejected if an item was not found.
     * @public
     */
    get(index: number): Promise<Item>;
    private _get(index);
    /**
     * Query items from the List
     * @private
     */
    protected queryItems(arg: any): Promise<Paginator<Item>>;
    /**
     * Query a list of items from collection.
     * @param {Object} args Arguments for query
     * @param {Number} args.from Item, which should be used as an anchor. If undefined, starts from the beginning or end depending on args.order
     * @param {Number} args.pageSize Results page size
     * @param {String} args.order Lexicographical order of results, should be 'asc' or 'desc'
     * @returns {Promise<Paginator<ListItem>>}
     * @public
     */
    getItems(args: any): Promise<Paginator<Item>>;
    /**
     * @return {Promise<Object>} Context of List
     * @private
     */
    getContext(): Promise<Object>;
    /**
     * @private
     */
    updateContext(context: any): Promise<this>;
    /**
     * Delete this list. It will be impossible to restore it.
     * @return {Promise<void>} A promise that resolves when the list has been deleted.
     * @public
     */
    removeList(): Promise<void>;
    protected onRemoved(locally: boolean): void;
    private shouldIgnoreEvent(key, eventId);
    /**
     * Handle update, which came from the server
     * @private
     */
    _update(update: any, isStrictlyOrdered: boolean): void;
    _advanceLastEventId(eventId: number, revision?: string): void;
    /**
     * Handle item insertion event, coming from server
     * @private
     */
    private _handleItemAdded(index, uri, eventId, revision, value);
    /**
     * Handle new value of item, coming from server
     * @private
     */
    private _handleItemUpdated(index, uri, eventId, revision, value);
    private _handleItemRemoved(index, eventId, oldData);
    private _handleContextUpdate(data, eventId);
}
export { ListServices, ListDescriptor, Mutator, SyncList };
export default SyncList;
