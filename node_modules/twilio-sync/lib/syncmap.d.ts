import { SyncEntity, EntityServices, RemovalHandler } from './entity';
import { MapItemDescriptor, MapItem as Item } from './mapitem';
import { Paginator } from './paginator';
import { Mutator } from './interfaces/mutator';
export interface MapServices extends EntityServices {
}
export interface MapDescriptor {
    sid: string;
    url: string;
    revision: string;
    last_event_id: number;
    links: any;
    unique_name: string;
    items?: MapItemDescriptor[];
}
/**
 * @class
 * @alias Map
 * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.
 * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.
 * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the
 * programmer to this map on creation. Unique among other Maps.
 *
 *
 * @fires Map#collectionRemoved
 * @fires Map#collectionRemovedRemotely
 * @fires Map#itemAdded
 * @fires Map#itemAddedRemotely
 * @fires Map#itemRemoved
 * @fires Map#itemRemovedRemotely
 * @fires Map#itemUpdated
 * @fires Map#itemUpdatedRemotely
 */
export declare class SyncMap extends SyncEntity {
    private readonly descriptor;
    private readonly actionQueue;
    private readonly cache;
    private context;
    /**
     * @private
     */
    constructor(services: MapServices, descriptor: MapDescriptor, removalHandler: RemovalHandler);
    readonly uri: string;
    readonly links: any;
    readonly revision: string;
    readonly lastEventId: number;
    static readonly type: string;
    readonly type: string;
    readonly sid: string;
    readonly uniqueName: string;
    _get(key: string): Promise<Item>;
    __set(location: string, param: any): any;
    /**
     * Update known existing element
     * @private
     */
    _set(location: string, keyValue: {
        key: string;
        revision?: string;
        data: Object;
    }, resolver?: Mutator): Promise<any>;
    /**
     * Create element or update if already existing
     * @private
     */
    private _tryAddOrUpdate(uri, keyValue, resolver?);
    /**
     * @return Promise<Object> Context of collection
     * @private
     */
    getContext(): Promise<Object>;
    /**
     * @param context {Object} New context value
     * @returns {Promise}
     * @private
     */
    updateContext(context: any): Promise<void>;
    /**
     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.
     * @param {String} key Unique item identifier
     * @param {Object} value Value to be set
     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.
     * @public
     */
    set(key: string, value: Object): Promise<Item>;
    /**
     * @private
     */
    _actualSet(key: string, value: Object, resolver?: Mutator): Promise<Item>;
    /**
     * Retrieve an item by key.
     * @param {String} key Identifies the desired item.
     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.
     * This promise will be rejected if item was not found.
     * @public
     */
    get(key: string): Promise<Item>;
    /**
     * Schedules a modification to this document that will apply a mutation function.
     * @param {String} key selects the map item to be mutated.
     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.
     * May be called multiple times, particularly if this Document is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the Document will have made the particular transition described
     * by this function.
     * @returns {Promise<MapItem>} Resolves with the modified item, with its latest contents.
     * @public
     */
    mutate(key: string, mutator: Mutator): Promise<Item>;
    /**
     * Modify the keyed map item by appending new fields (or by overwriting existing ones) with the values from
     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values
     * into it.
     * @param {String} key selects the map item to update.
     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.
     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.
     * @public
     */
    update(key: string, obj: Object): Promise<Item>;
    /**
     * Delete an item, given its key.
     * @param {String} key selects the item to delete.
     * @returns {Promise<void>} A promise to remove an item.
     * The promise will be rejected if 'key' is undefined or an item was not found.
     * @public
     */
    remove(key: string): Promise<void>;
    /**
     * @private
     */
    protected queryItems(args?: any): Promise<Paginator<Item>>;
    /**
     * Get a complete list of items from the map.
     * @param {Object} args Arguments for query
     * @param {String} args.from Item, which should be used as an anchor. If undefined, starts from the beginning or end depending on args.order
     * @param {Number} args.pageSize Result page size
     * @param {String} args.order Lexicographical order of results, should be 'asc' or 'desc'
     * @return {Promise<Paginator<MapItem>>}
     * @public
     */
    getItems(args?: any): Promise<Paginator<Item>>;
    /**
     * Enumerate all items in this Map.
     * This always triggers server interaction when being called for the first time on a Map; this may be latent.
     * This method not supported now and not meant to be used externally.
     * @param {Function} handler Function to handle each argument
     * @private
     */
    forEach(handler: any): Promise<{}>;
    private shouldIgnoreEvent(key, eventId);
    /**
     * Handle update from the server
     * @private
     */
    _update(update: any, isStrictlyOrdered: boolean): void;
    _advanceLastEventId(eventId: number, revision?: string): void;
    /**
     * Handle entity insertion event, coming from server
     * @private
     */
    protected _handleItemAdded(key: string, url: string, eventId: number, revision: string, value: Object): void;
    /**
     * Handle new value of entity, coming from server
     * @private
     */
    protected _handleItemUpdated(key: string, url: string, eventId: number, revision: string, value: Object): void;
    /**
     * @private
     */
    protected _handleItemRemoved(key: any, eventId: any, oldData: any): void;
    protected _handleContextUpdate(data: any, eventId: any): void;
    protected onRemoved(locally: boolean): void;
    /**
     * Delete this map. It will be impossible to restore it.
     * @return {Promise<void>} A promise that resolves when the map has been deleted.
     * @public
     */
    removeMap(): Promise<void>;
}
export default SyncMap;
