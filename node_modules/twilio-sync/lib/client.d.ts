/// <reference types="node" />
import { EventEmitter } from 'events';
import { SyncDocument } from './syncdocument';
import { SyncList } from './synclist';
import { SyncMap } from './syncmap';
import { SyncStream } from './streams/syncstream';
export declare type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'disconnecting' | 'denied' | 'error';
/**
 * @class Client
 * @classdesc
 * Client for the Twilio Sync service
 *
 * @property {Client#ConnectionState} connectionState - Contains current service connection state.
 * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].
 */
declare class Client extends EventEmitter {
    private readonly services;
    private readonly entities;
    private readonly productId;
    private fpaToken;
    private localStorageId;
    private readonly authData;
    constructor(fpaToken: string, options?: any);
    /**
     * Current version of Sync client.
     * @name Client#version
     * @type String
     * @readonly
     */
    static readonly version: any;
    readonly connectionState: ConnectionState;
    private handleEmsResponse(response);
    /**
     * Returns promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     * @private
     */
    private ensureReady();
    private storeRootInSessionCache(type, id, value);
    private readRootFromSessionCache(type, id);
    private _get(baseUri, id, optimistic?);
    private _createDocument(id, data?);
    private _getDocument(id);
    private _createList(id, purpose?, context?);
    private _getList(id);
    private _createMap(id);
    private _getMap(id, optimistic?);
    private _getStream(id, optimistic?);
    private _createStream(id);
    private getCached<T>(id, type);
    private removeFromCacheAndSession(type, sid, uniqueName);
    /**
     * Open a Sync Document by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Document.
     * @return {Promise<List>} a promise which resolves after the document is successfully read (or created).
     * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    document(arg?: any): Promise<SyncDocument>;
    /**
     * Open a Sync Map by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Map.
     * @return {Promise<Map>} a promise which resolves after the map is successfully read (or created).
     * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    map(arg?: any): Promise<SyncMap>;
    /**
     * Open a Sync List by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync List.
     * @return {Promise<List>} a promise which resolves after the list is successfully read (or created).
     * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access to it.
     * @public
     */
    list(arg?: any): Promise<SyncList>;
    /**
     * Open a Sync Message Stream (SyncStream) by identifier, or create one if none exists
     * @param {string} id a Unique name or SID identifying a Sync Message Stream.
     * @return {Promise<Stream>} a promise which resolves after the stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     */
    stream(arg?: any): Promise<SyncStream>;
    /**
     * Gracefully shutdown the libray
     * Currently it is not properly implemented and being used only in tests
     * But should be made a part of public API
     * @private
     */
    shutdown(): Promise<void>;
    /**
     * Set new auth token
     * @param {string} token New token to set
     * @return {Promise}
     * @public
     */
    updateToken(token: string): Promise<void>;
}
export { Client, Client as SyncClient };
export default Client;
