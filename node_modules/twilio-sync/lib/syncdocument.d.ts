import { SyncEntity, EntityServices, RemovalHandler } from './entity';
import { Mutator } from './interfaces/mutator';
interface DocumentServices extends EntityServices {
}
interface DocumentDescriptor {
    url: string;
    sid: string;
    revision: string;
    last_event_id: number;
    unique_name: string;
    data: Object;
}
/**
 * @class
 * @alias Document
 * @classdesc Represents a Sync Document, the contents of which is a single JSON object.
 * @property {String} sid The immutable identifier of this document, assigned by the system.
 * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer
 * to this document during creation. Globally unique among other Documents.
 * @property {Object} value The contents of this document.
 *
 * @fires Document#removed
 * @fires Document#removedRemotely
 * @fires Document#updated
 * @fires Document#updatedRemotely
 */
declare class SyncDocument extends SyncEntity {
    private readonly actionQueue;
    private readonly descriptor;
    /**
     * @private
     */
    constructor(services: DocumentServices, descriptor: DocumentDescriptor, removalHandler: RemovalHandler);
    readonly uri: string;
    readonly revision: string;
    readonly lastEventId: number;
    static readonly type: string;
    readonly type: string;
    readonly sid: string;
    readonly value: Object;
    readonly uniqueName: string;
    /**
     * Update data entity with new data
     * @private
     */
    _update(update: any): void;
    /**
     * Calculate diff between old and new data
     * @private
     */
    private traverse(originalData, updatedData, isLocalEvent);
    /**
     * @returns {Object} Internal data of entity
     * For now use a 'value' property instead
     * @private
     */
    private get(path);
    /**
     * Assign new contents to this document.
     * @param {Object} value The new contents to assign.
     * @param {Boolean} [conditional=false] Determines whether to detect remote modifications that would race
     * with this new value.
     * @returns {Promise<Object>} A promise describing the outcome of the set.
     * Among common network failures and incorrect permissions, this promise will be rejected if value was
     * remotely modified and the `conditional` flag was set.
     * @public
     */
    set(value: Object, conditional: any): Promise<Object>;
    /**
     * @private
     */
    private _actualSet(data, conflictResolver);
    /**
     * Schedules a modification to this document that will apply a mutation function.
     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.
     * May be called multiple times, particularly if this Document is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the Document will have made the particular transition described
     * by this function.
     * @return {Promise<Object>}
     * @public
     */
    mutate(mutator: Mutator): Promise<Object>;
    /**
     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.
     * @return {Promise<Object>} A promise resolving to the modified item in its new state.
     * @public
     */
    update(obj: Object): Promise<Object>;
    _set(context: any, param: any): Promise<{
        revision: any;
        data: any;
        last_event_id: any;
    }>;
    /**
     * Get new data from server
     * @private
     */
    protected softSync(): any;
    /**
     * Get value by given path
     * @param {string} path JSON path
     * @private
     */
    protected onRemoved(locally: boolean): void;
    /**
     * Delete a document
     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.
     * @public
     */
    removeDocument(): Promise<void>;
}
export { DocumentServices, DocumentDescriptor, Mutator, SyncDocument };
export default SyncDocument;
