"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var xxhashjs_1 = require("xxhashjs");
var Twilsock = require("twilsock");
var twilio_transport_1 = require("twilio-transport");
var twilio_ems_client_1 = require("twilio-ems-client");
var Notifications = require("twilio-notifications");
var utils_1 = require("./utils");
var logger_1 = require("./logger");
var configuration_1 = require("./configuration");
var subscriptions_1 = require("./subscriptions");
var router_1 = require("./router");
var network_1 = require("./network");
var syncdocument_1 = require("./syncdocument");
var synclist_1 = require("./synclist");
var syncmap_1 = require("./syncmap");
var clientInfo_1 = require("./clientInfo");
var entitiesCache_1 = require("./entitiesCache");
var storage_1 = require("./services/storage");
var utils_2 = require("./utils");
// TODO: Pick some small library and use it instead
var deferred_1 = require("./utils/deferred");
var syncerror_1 = require("./syncerror");
var syncstream_1 = require("./streams/syncstream");
var SYNC_PRODUCT_ID = 'data_sync';
var SDK_VERSION = require('../package.json').version;
function subscribe(subscribable) {
    subscribable._subscribe();
    return subscribable;
}
function createPayload(name, purpose, context, data) {
    return { unique_name: name,
        purpose: purpose,
        context: context,
        data: data };
}
function decompose(arg) {
    if (!arg) {
        return { id: null, purpose: null, data: null, context: null, mode: null, optimistic: false };
    }
    if (typeof arg === 'string') {
        return { id: arg, purpose: null, data: null, context: null, mode: null, optimistic: false };
    }
    return { id: arg.uniqueName || arg.sid || arg.id,
        purpose: arg.purpose,
        data: arg.data,
        context: arg.context,
        mode: arg.mode,
        optimistic: !!arg.optimistic };
}
/**
 * @class Client
 * @classdesc
 * Client for the Twilio Sync service
 *
 * @property {Client#ConnectionState} connectionState - Contains current service connection state.
 * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].
 */

var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    /*
     * @constructor
     * @param {string} Token Twilio access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     */
    function Client(fpaToken) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        if (!fpaToken) {
            throw new Error('Sync library needs a valid Twilio token to be passed');
        }
        if (options.hasOwnProperty('logLevel')) {
            logger_1.default.setLevel(options.logLevel);
        }
        _this.productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        var twilsock = options.twilsockClient = options.twilsockClient || new Twilsock(fpaToken, options);
        var transport = options.transport = options.transport || new twilio_transport_1.Transport(options.twilsockClient, { concurrentHttpRequestLimit: 20 });
        var emsClient = options.emsClient = options.emsClient || new twilio_ems_client_1.EmsClient(options);
        var notifications = options.notificationsClient = options.notificationsClient || new Notifications(fpaToken, options);
        var config = new configuration_1.Configuration(null, options);
        var network = new network_1.Network(_this.productId, new clientInfo_1.ClientInfo(SDK_VERSION), config, transport);
        var storage = new storage_1.SessionStorage(config);
        _this.localStorageId = null;
        _this.fpaToken = fpaToken;
        _this.authData = new deferred_1.Deferred();
        _this.authData.promise.then(function (response) {
            return _this.handleEmsResponse(response);
        });
        emsClient.once('response', function (response) {
            return _this.authData.update(response);
        });
        emsClient.setToken(fpaToken).catch(function (e) {
            logger_1.default.warn('Failed to set token', e);
        });
        twilsock.connect();
        _this.services = {
            config: config,
            twilsock: twilsock,
            notifications: notifications,
            network: network,
            emsClient: emsClient,
            storage: storage,
            router: null,
            subscriptions: null
        };
        var subscriptions = new subscriptions_1.Subscriptions(_this.services);
        var router = new router_1.Router({ config: config, subscriptions: subscriptions, notifications: notifications });
        _this.services.router = router;
        _this.services.subscriptions = subscriptions;
        _this.entities = new entitiesCache_1.EntitiesCache();
        notifications.on('connectionStateChanged', function () {
            _this.emit('connectionStateChanged', _this.services.notifications.connectionState);
        });
        return _this;
    }
    /**
     * Current version of Sync client.
     * @name Client#version
     * @type String
     * @readonly
     */


    (0, _createClass3.default)(Client, [{
        key: "handleEmsResponse",
        value: function handleEmsResponse(response) {
            this.services.config.updateToken(response.token);
            try {
                var identity = response.identity;
                var serviceSid = response.serviceSids[this.productId];
                var storageId = xxhashjs_1.h64().update("TW::" + identity + "::" + serviceSid).digest().toString(16);
                this.services.storage.updateStorageId(storageId);
            } catch (e) {
                logger_1.default.error('Failed to initialize persistent storage', e);
            }
        }
        /**
         * Returns promise which resolves when library is correctly initialized
         * Or throws if initialization is impossible
         * @private
         */

    }, {
        key: "ensureReady",
        value: function ensureReady() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.authData.promise;

                            case 2:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        }
    }, {
        key: "storeRootInSessionCache",
        value: function storeRootInSessionCache(type, id, value) {
            // can't store without id
            if (!this.services.config.sessionStorageEnabled || !id) {
                return;
            }
            var valueToStore = utils_2.deepClone(value);
            if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {
                valueToStore['last_event_id'] = null;
                delete valueToStore['items'];
            }
            this.services.storage.store(type, id, valueToStore);
        }
    }, {
        key: "readRootFromSessionCache",
        value: function readRootFromSessionCache(type, id) {
            if (!this.services.config.sessionStorageEnabled || !id) {
                return null;
            }
            return this.services.storage.read(type, id);
        }
    }, {
        key: "_get",
        value: function _get(baseUri, id) {
            var optimistic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                var uri, response;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (id) {
                                    _context2.next = 2;
                                    break;
                                }

                                return _context2.abrupt("return", null);

                            case 2:
                                uri = new utils_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();
                                _context2.prev = 3;
                                _context2.next = 6;
                                return this.services.network.get(uri);

                            case 6:
                                response = _context2.sent;
                                return _context2.abrupt("return", response.body);

                            case 10:
                                _context2.prev = 10;
                                _context2.t0 = _context2["catch"](3);

                                if (!(_context2.t0.status === 404)) {
                                    _context2.next = 14;
                                    break;
                                }

                                return _context2.abrupt("return", null);

                            case 14:
                                throw _context2.t0;

                            case 15:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this, [[3, 10]]);
            }));
        }
    }, {
        key: "_createDocument",
        value: function _createDocument(id, data) {
            var requestBody = {
                unique_name: id,
                data: data
            };
            return this.services.network.post(this.services.config.documentsUri, requestBody).then(function (response) {
                return response.body;
            });
        }
    }, {
        key: "_getDocument",
        value: function _getDocument(id) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt("return", this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));

                            case 1:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
    }, {
        key: "_createList",
        value: function _createList(id, purpose, context) {
            var payload = createPayload(id, purpose, context);
            return this.services.network.post(this.services.config.listsUri, payload).then(function (response) {
                return response.body;
            });
        }
    }, {
        key: "_getList",
        value: function _getList(id) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                return _context4.abrupt("return", this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));

                            case 1:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));
        }
    }, {
        key: "_createMap",
        value: function _createMap(id) {
            var requestBody = {
                unique_name: id
            };
            return this.services.network.post(this.services.config.mapsUri, requestBody).then(function (response) {
                return response.body;
            });
        }
    }, {
        key: "_getMap",
        value: function _getMap(id) {
            var optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                return _context5.abrupt("return", this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));

                            case 1:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));
        }
    }, {
        key: "_getStream",
        value: function _getStream(id) {
            var optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                return _context6.abrupt("return", this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, optimistic));

                            case 1:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));
        }
    }, {
        key: "_createStream",
        value: function _createStream(id) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
                var requestBody, response, streamDescriptor;
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                requestBody = {
                                    unique_name: id
                                };
                                _context7.next = 3;
                                return this.services.network.post(this.services.config.streamsUri, requestBody);

                            case 3:
                                response = _context7.sent;
                                streamDescriptor = response.body;
                                return _context7.abrupt("return", streamDescriptor);

                            case 6:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));
        }
    }, {
        key: "getCached",
        value: function getCached(id, type) {
            if (id) {
                return this.entities.get(id, type) || null;
            }
            return null;
        }
    }, {
        key: "removeFromCacheAndSession",
        value: function removeFromCacheAndSession(type, sid, uniqueName) {
            this.entities.remove(sid);
            if (this.services.config.sessionStorageEnabled) {
                this.services.storage.remove(type, sid, uniqueName);
            }
        }
        /**
         * Open a Sync Document by identifier, or create one if none exists
         * @param {string} id a Unique name or SID identifying a Sync Document.
         * @return {Promise<List>} a promise which resolves after the document is successfully read (or created).
         * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access to it.
         * @public
         */

    }, {
        key: "document",
        value: function document(arg) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
                var _this2 = this;

                var _decompose, id, data, mode, docFromInMemoryCache, docDescriptor, syncDocument;

                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                _context8.next = 2;
                                return this.ensureReady();

                            case 2:
                                _decompose = decompose(arg), id = _decompose.id, data = _decompose.data, mode = _decompose.mode;
                                docFromInMemoryCache = this.getCached(id, 'document');

                                if (!docFromInMemoryCache) {
                                    _context8.next = 8;
                                    break;
                                }

                                return _context8.abrupt("return", docFromInMemoryCache);

                            case 8:
                                _context8.next = 10;
                                return this._getDocument(id);

                            case 10:
                                docDescriptor = _context8.sent;

                                if (docDescriptor) {
                                    _context8.next = 29;
                                    break;
                                }

                                if (!(mode === 'open')) {
                                    _context8.next = 16;
                                    break;
                                }

                                throw new syncerror_1.default('Not found', 404);

                            case 16:
                                _context8.prev = 16;
                                _context8.next = 19;
                                return this._createDocument(id, data);

                            case 19:
                                docDescriptor = _context8.sent;
                                _context8.next = 29;
                                break;

                            case 22:
                                _context8.prev = 22;
                                _context8.t0 = _context8["catch"](16);

                                if (!(_context8.t0.status === 409)) {
                                    _context8.next = 28;
                                    break;
                                }

                                return _context8.abrupt("return", this.document(arg));

                            case 28:
                                throw _context8.t0;

                            case 29:
                                this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, id, docDescriptor);
                                syncDocument = new syncdocument_1.SyncDocument(this.services, docDescriptor, function (type, sid, uniqueName) {
                                    return _this2.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncDocument = this.entities.store(syncDocument);
                                return _context8.abrupt("return", subscribe(syncDocument));

                            case 33:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this, [[16, 22]]);
            }));
        }
        /**
         * Open a Sync Map by identifier, or create one if none exists
         * @param {string} id a Unique name or SID identifying a Sync Map.
         * @return {Promise<Map>} a promise which resolves after the map is successfully read (or created).
         * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access to it.
         * @public
         */

    }, {
        key: "map",
        value: function map(arg) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                var _this3 = this;

                var _decompose2, id, mode, optimistic, mapFromInMemoryCache, mapDescriptor, syncMap;

                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                _context9.next = 2;
                                return this.ensureReady();

                            case 2:
                                _decompose2 = decompose(arg), id = _decompose2.id, mode = _decompose2.mode, optimistic = _decompose2.optimistic;
                                mapFromInMemoryCache = this.getCached(id, 'map');

                                if (!mapFromInMemoryCache) {
                                    _context9.next = 8;
                                    break;
                                }

                                return _context9.abrupt("return", mapFromInMemoryCache);

                            case 8:
                                _context9.next = 10;
                                return this._getMap(id, optimistic);

                            case 10:
                                mapDescriptor = _context9.sent;

                                if (mapDescriptor) {
                                    _context9.next = 29;
                                    break;
                                }

                                if (!(mode === 'open')) {
                                    _context9.next = 16;
                                    break;
                                }

                                throw new syncerror_1.default('Not found', 404);

                            case 16:
                                _context9.prev = 16;
                                _context9.next = 19;
                                return this._createMap(id);

                            case 19:
                                mapDescriptor = _context9.sent;
                                _context9.next = 29;
                                break;

                            case 22:
                                _context9.prev = 22;
                                _context9.t0 = _context9["catch"](16);

                                if (!(_context9.t0.status === 409)) {
                                    _context9.next = 28;
                                    break;
                                }

                                return _context9.abrupt("return", this.map(arg));

                            case 28:
                                throw _context9.t0;

                            case 29:
                                this.storeRootInSessionCache(syncmap_1.SyncMap.type, id, mapDescriptor);
                                syncMap = new syncmap_1.SyncMap(this.services, mapDescriptor, function (type, sid, uniqueName) {
                                    return _this3.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncMap = this.entities.store(syncMap);
                                return _context9.abrupt("return", subscribe(syncMap));

                            case 33:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this, [[16, 22]]);
            }));
        }
        /**
         * Open a Sync List by identifier, or create one if none exists
         * @param {string} id a Unique name or SID identifying a Sync List.
         * @return {Promise<List>} a promise which resolves after the list is successfully read (or created).
         * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access to it.
         * @public
         */

    }, {
        key: "list",
        value: function list(arg) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
                var _this4 = this;

                var _decompose3, id, purpose, context, mode, listFromInMemoryCache, listDescriptor, syncList;

                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                _context10.next = 2;
                                return this.ensureReady();

                            case 2:
                                _decompose3 = decompose(arg), id = _decompose3.id, purpose = _decompose3.purpose, context = _decompose3.context, mode = _decompose3.mode;
                                listFromInMemoryCache = this.getCached(id, 'list');

                                if (!listFromInMemoryCache) {
                                    _context10.next = 8;
                                    break;
                                }

                                return _context10.abrupt("return", listFromInMemoryCache);

                            case 8:
                                _context10.next = 10;
                                return this._getList(id);

                            case 10:
                                listDescriptor = _context10.sent;

                                if (listDescriptor) {
                                    _context10.next = 29;
                                    break;
                                }

                                if (!(mode === 'open')) {
                                    _context10.next = 16;
                                    break;
                                }

                                throw new syncerror_1.default('Not found', 404);

                            case 16:
                                _context10.prev = 16;
                                _context10.next = 19;
                                return this._createList(id, purpose, context);

                            case 19:
                                listDescriptor = _context10.sent;
                                _context10.next = 29;
                                break;

                            case 22:
                                _context10.prev = 22;
                                _context10.t0 = _context10["catch"](16);

                                if (!(_context10.t0.status === 409)) {
                                    _context10.next = 28;
                                    break;
                                }

                                return _context10.abrupt("return", this.list(arg));

                            case 28:
                                throw _context10.t0;

                            case 29:
                                this.storeRootInSessionCache(synclist_1.SyncList.type, id, listDescriptor);
                                syncList = new synclist_1.SyncList(this.services, listDescriptor, function (type, sid, uniqueName) {
                                    return _this4.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncList = this.entities.store(syncList);
                                return _context10.abrupt("return", subscribe(syncList));

                            case 33:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this, [[16, 22]]);
            }));
        }
        /**
         * Open a Sync Message Stream (SyncStream) by identifier, or create one if none exists
         * @param {string} id a Unique name or SID identifying a Sync Message Stream.
         * @return {Promise<Stream>} a promise which resolves after the stream is successfully read (or created).
         * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
         * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
         * @public
         */

    }, {
        key: "stream",
        value: function stream(arg) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee11() {
                var _this5 = this;

                var _decompose4, id, mode, optimistic, streamFromInMemoryCache, streamDescriptor, streamRemovalHandler, syncStream;

                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                _context11.next = 2;
                                return this.ensureReady();

                            case 2:
                                _decompose4 = decompose(arg), id = _decompose4.id, mode = _decompose4.mode, optimistic = _decompose4.optimistic;
                                streamFromInMemoryCache = this.getCached(id, syncstream_1.SyncStream.type);

                                if (!streamFromInMemoryCache) {
                                    _context11.next = 8;
                                    break;
                                }

                                return _context11.abrupt("return", streamFromInMemoryCache);

                            case 8:
                                _context11.next = 10;
                                return this._getStream(id, optimistic);

                            case 10:
                                streamDescriptor = _context11.sent;

                                if (streamDescriptor) {
                                    _context11.next = 29;
                                    break;
                                }

                                if (!(mode === 'open')) {
                                    _context11.next = 16;
                                    break;
                                }

                                throw new syncerror_1.default('Not found', 404);

                            case 16:
                                _context11.prev = 16;
                                _context11.next = 19;
                                return this._createStream(id);

                            case 19:
                                streamDescriptor = _context11.sent;
                                _context11.next = 29;
                                break;

                            case 22:
                                _context11.prev = 22;
                                _context11.t0 = _context11["catch"](16);

                                if (!(_context11.t0.status === 409)) {
                                    _context11.next = 28;
                                    break;
                                }

                                return _context11.abrupt("return", this.stream(arg));

                            case 28:
                                throw _context11.t0;

                            case 29:
                                this.storeRootInSessionCache(syncstream_1.SyncStream.type, id, streamDescriptor);

                                streamRemovalHandler = function streamRemovalHandler(type, sid, uniqueName) {
                                    return _this5.removeFromCacheAndSession(type, sid, uniqueName);
                                };

                                syncStream = new syncstream_1.SyncStream(this.services, streamDescriptor, streamRemovalHandler);

                                syncStream = this.entities.store(syncStream);
                                return _context11.abrupt("return", subscribe(syncStream));

                            case 34:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this, [[16, 22]]);
            }));
        }
        /**
         * Gracefully shutdown the libray
         * Currently it is not properly implemented and being used only in tests
         * But should be made a part of public API
         * @private
         */

    }, {
        key: "shutdown",
        value: function shutdown() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
                return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                        switch (_context12.prev = _context12.next) {
                            case 0:
                                _context12.next = 2;
                                return this.services.subscriptions.shutdown();

                            case 2:
                                _context12.next = 4;
                                return this.services.twilsock.disconnect();

                            case 4:
                            case "end":
                                return _context12.stop();
                        }
                    }
                }, _callee12, this);
            }));
        }
        /**
         * Set new auth token
         * @param {string} token New token to set
         * @return {Promise}
         * @public
         */

    }, {
        key: "updateToken",
        value: function updateToken(token) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
                var response;
                return _regenerator2.default.wrap(function _callee13$(_context13) {
                    while (1) {
                        switch (_context13.prev = _context13.next) {
                            case 0:
                                _context13.next = 2;
                                return this.services.emsClient.setToken(token);

                            case 2:
                                response = _context13.sent;

                                this.services.config.updateToken(response.token);
                                _context13.next = 6;
                                return _promise2.default.all([this.services.notifications.updateToken(token), this.services.twilsock.updateToken(token)]);

                            case 6:
                                this.fpaToken = token;

                            case 7:
                            case "end":
                                return _context13.stop();
                        }
                    }
                }, _callee13, this);
            }));
        }
    }, {
        key: "connectionState",
        get: function get() {
            return this.services.notifications.connectionState;
        }
    }], [{
        key: "version",
        get: function get() {
            return SDK_VERSION;
        }
    }]);
    return Client;
}(events_1.EventEmitter);

exports.Client = Client;
exports.SyncClient = Client;
exports.default = Client;
/**
 * Indicates current state of connection between the client and Sync service.
 * <p>Valid options are as follows:
 * <li>'connecting' - client is offline and connection attempt is in process.
 * <li>'connected' - client is online and ready.
 * <li>'disconnecting' - client is going offline as disconnection is in process.
 * <li>'disconnected' - client is offline and no connection attempt is in process.
 * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.
 * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.
 * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState
 */
/**
 * These options can be passed to Client constructor
 * @typedef {Object} Client#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
 */
/**
 * Fired when connection state has been changed.
 * @param {Client#ConnectionState} connectionState Contains current service connection state.
 * @event Client#connectionStateChanged
 */