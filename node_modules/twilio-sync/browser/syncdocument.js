"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("./logger");
var entity_1 = require("./entity");
var rfc6902_1 = require("rfc6902");
var retryingqueue_1 = require("./retryingqueue");
var utils_1 = require("./utils");
/**
 * @class
 * @alias Document
 * @classdesc Represents a Sync Document, the contents of which is a single JSON object.
 * @property {String} sid The immutable identifier of this document, assigned by the system.
 * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer
 * to this document during creation. Globally unique among other Documents.
 * @property {Object} value The contents of this document.
 *
 * @fires Document#removed
 * @fires Document#removedRemotely
 * @fires Document#updated
 * @fires Document#updatedRemotely
 */

var SyncDocument = function (_entity_1$SyncEntity) {
    (0, _inherits3.default)(SyncDocument, _entity_1$SyncEntity);

    /**
     * @private
     */
    function SyncDocument(services, descriptor, removalHandler) {
        (0, _classCallCheck3.default)(this, SyncDocument);

        var _this = (0, _possibleConstructorReturn3.default)(this, (SyncDocument.__proto__ || (0, _getPrototypeOf2.default)(SyncDocument)).call(this, services, removalHandler));

        _this.actionQueue = new retryingqueue_1.RetryingQueue();
        _this.descriptor = descriptor;
        _this.descriptor.data = _this.descriptor.data || {};
        return _this;
    }
    // private props


    (0, _createClass3.default)(SyncDocument, [{
        key: "_update",

        /**
         * Update data entity with new data
         * @private
         */
        value: function _update(update) {
            switch (update.type) {
                case 'document_updated':
                    if (update.id > this.lastEventId) {
                        var originalData = this.descriptor.data;
                        this.descriptor.last_event_id = update.id;
                        this.descriptor.revision = update.document_revision;
                        this.descriptor.data = update.document_data;
                        this.traverse(originalData, update.document_data, false);
                        this.emit('updated', update.document_data, false);
                        this.emit('updatedRemotely', update.document_data);
                        this.services.storage.update(this.type, this.sid, this.uniqueName, { last_event_id: update.id, revision: update.document_revision, data: update.document_data });
                    }
                    break;
                case 'document_removed':
                    this.onRemoved(false);
                    break;
            }
        }
        /**
         * Calculate diff between old and new data
         * @private
         */

    }, {
        key: "traverse",
        value: function traverse(originalData, updatedData, isLocalEvent) {
            var _this2 = this;

            var diff = rfc6902_1.createPatch(originalData, updatedData);
            diff.forEach(function (row) {
                if (row.op === 'add') {
                    _this2.emit('keyAdded', row.path, row.value, isLocalEvent);
                    if (!isLocalEvent) {
                        _this2.emit('keyAddedRemotely', row.path, row.value);
                    }
                } else if (row.op === 'replace') {
                    _this2.emit('keyUpdated', row.path, row.value, isLocalEvent);
                    if (!isLocalEvent) {
                        _this2.emit('keyUpdatedRemotely', row.path, row.value);
                    }
                } else if (row.op === 'remove') {
                    _this2.emit('keyRemoved', row.path, isLocalEvent);
                    if (!isLocalEvent) {
                        _this2.emit('keyRemovedRemotely', row.path);
                    }
                }
            });
        }
        /**
         * @returns {Object} Internal data of entity
         * For now use a 'value' property instead
         * @private
         */

    }, {
        key: "get",
        value: function get(path) {
            // return !path ? this.value : this.value(path);
            return this.value;
        }
        /**
         * Assign new contents to this document.
         * @param {Object} value The new contents to assign.
         * @param {Boolean} [conditional=false] Determines whether to detect remote modifications that would race
         * with this new value.
         * @returns {Promise<Object>} A promise describing the outcome of the set.
         * Among common network failures and incorrect permissions, this promise will be rejected if value was
         * remotely modified and the `conditional` flag was set.
         * @public
         */

    }, {
        key: "set",
        value: function set(value, conditional) {
            return this._actualSet(value, conditional ? function () {
                throw new Error('Revision mismatch');
            } : null);
        }
        /**
         * @private
         */

    }, {
        key: "_actualSet",
        value: function _actualSet(data, conflictResolver) {
            var _this3 = this;

            var resolver = void 0;
            var arg = { data: data,
                revision: conflictResolver ? this.revision : undefined };
            if (conflictResolver) {
                resolver = function resolver(err) {
                    return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                        return _regenerator2.default.wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        if (!(err.status === 412)) {
                                            _context.next = 4;
                                            break;
                                        }

                                        _context.next = 3;
                                        return this.softSync();

                                    case 3:
                                        return _context.abrupt("return", { revision: this.revision,
                                            data: conflictResolver(utils_1.deepClone(this.value)) });

                                    case 4:
                                        throw err;

                                    case 5:
                                    case "end":
                                        return _context.stop();
                                }
                            }
                        }, _callee, this);
                    }));
                };
            }
            return this.actionQueue.add(this._set.bind(this), this.uri, arg, resolver).then(function (result) {
                if (result.last_event_id > _this3.descriptor.last_event_id) {
                    // Ignore returned value if we already got a newer one
                    _this3.descriptor.revision = result.revision;
                    _this3.descriptor.data = result.data;
                    _this3.descriptor.last_event_id = result.last_event_id;
                    _this3.services.storage.update(_this3.type, _this3.sid, _this3.uniqueName, { last_event_id: result.last_event_id, revision: result.revision, data: result.data });
                }
                _this3.emit('updated', _this3.value, true);
                return _this3.value;
            });
        }
        /**
         * Schedules a modification to this document that will apply a mutation function.
         * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.
         * May be called multiple times, particularly if this Document is modified concurrently by remote code.
         * If the mutation ultimately succeeds, the Document will have made the particular transition described
         * by this function.
         * @return {Promise<Object>}
         * @public
         */

    }, {
        key: "mutate",
        value: function mutate(mutator) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                return _context2.abrupt("return", this._actualSet(mutator(utils_1.deepClone(this.value)), mutator));

                            case 1:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        }
        /**
         * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
         * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.
         * @return {Promise<Object>} A promise resolving to the modified item in its new state.
         * @public
         */

    }, {
        key: "update",
        value: function update(obj) {
            return this.mutate(function (remote) {
                return (0, _extends3.default)(remote, obj);
            });
        }
    }, {
        key: "_set",
        value: function _set(context, param) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var response;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this.services.network.post(this.uri, { data: param.data }, param.revision);

                            case 2:
                                response = _context3.sent;
                                return _context3.abrupt("return", { revision: response.body.revision, data: param.data, last_event_id: response.body.last_event_id });

                            case 4:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
        /**
         * Get new data from server
         * @private
         */

    }, {
        key: "softSync",
        value: function softSync() {
            var _this4 = this;

            return this.services.network.get(this.uri).then(function (response) {
                _this4._update({ type: 'document_updated',
                    id: response.body.last_event_id,
                    document_revision: response.body.revision,
                    document_data: response.body.data }); // eslint-disable-line camelcase
                return _this4;
            }).catch(function (err) {
                if (err.status === 404) {
                    _this4.onRemoved(false);
                } else {
                    logger_1.default.error("Can't get updates for " + _this4.sid + ":", err);
                }
            });
        }
        /**
         * Get value by given path
         * @param {string} path JSON path
         * @private
         */
        /*
        _value(path) {
          let result;
          try {
            let pathArr = path.replace(/^\/|\/$/gm, '').split('/');
            let obj = this.data;
            pathArr.forEach((el) => { obj = obj[el]; });
            result = obj;
          } catch (e) {
            log.warn('Failed to get value:', e);
          }
          return result;
        }
        */

    }, {
        key: "onRemoved",
        value: function onRemoved(locally) {
            this._unsubscribe();
            this.removalHandler(this.type, this.sid, this.uniqueName);
            // Should also do some cleanup here
            this.emit('removed', locally);
            if (!locally) {
                this.emit('removedRemotely');
            }
        }
        /**
         * Delete a document
         * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.
         * @public
         */

    }, {
        key: "removeDocument",
        value: function removeDocument() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                _context4.next = 2;
                                return this.services.network.delete(this.uri);

                            case 2:
                                this.onRemoved(true);

                            case 3:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));
        }
    }, {
        key: "uri",
        get: function get() {
            return this.descriptor.url;
        }
    }, {
        key: "revision",
        get: function get() {
            return this.descriptor.revision;
        }
    }, {
        key: "lastEventId",
        get: function get() {
            return this.descriptor.last_event_id;
        }
    }, {
        key: "type",
        get: function get() {
            return 'document';
        }
        // public props, documented along with class description

    }, {
        key: "sid",
        get: function get() {
            return this.descriptor.sid;
        }
    }, {
        key: "value",
        get: function get() {
            return this.descriptor.data;
        }
    }, {
        key: "uniqueName",
        get: function get() {
            return this.descriptor.unique_name || null;
        }
    }], [{
        key: "type",
        get: function get() {
            return 'document';
        }
    }]);
    return SyncDocument;
}(entity_1.SyncEntity);

exports.SyncDocument = SyncDocument;
exports.default = SyncDocument;
/**
 * Applies a transformation to the document value.
 * @callback Document~Mutator
 * @param {Object} data The current value of the item in the cloud.
 * @return {Object} The desired new value for the item.
 */
/**
 * Fired when the document is removed, whether the remover was local or remote.
 * @event Document#removed
 * @param {Boolean} - 'true' if the item was removed by local code, 'false' otherwise
 */
/**
 * Fired when the document is removed by remote code.
 * @event Document#removedRemotely
 */
/**
 * Fired when the document's contents have changed, whether the updater was local or remote.
 * @event Document#updated
 * @param {Object} - A snapshot of the document's new contents.
 * @param {Boolean} - Equals 'true' if item was removed by local actor, 'false' otherwise
 */
/**
 * Fired when a document's contents were changed by remote code.
 * @event Document#updatedRemotely
 * @param {Object} - A snapshot of the document's new contents.
 */